name: Deploy Application to Azure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.github/**'
      - 'docs/**'

env:
  VM_IP: 4.157.253.229
  VM_USER: azureuser
  APP_DIR: /opt/jobtracker

jobs:
  deploy:
    name: Deploy to Azure VM
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: http://${{ env.VM_IP }}:3000

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AZURE_SSH_KEY }}" > ~/.ssh/azure_key
          chmod 600 ~/.ssh/azure_key
          ssh-keyscan -H ${{ env.VM_IP }} >> ~/.ssh/known_hosts

      - name: Check VM connectivity
        run: |
          ssh -i ~/.ssh/azure_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_IP }} "echo 'VM is reachable'"

      - name: Check cloud-init status
        run: |
          echo "Checking if cloud-init has completed..."
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} "sudo cloud-init status --wait"

      - name: Setup application directory
        run: |
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} << 'ENDSSH'
            # Create directory if it doesn't exist
            sudo mkdir -p ${{ env.APP_DIR }}
            sudo chown -R ${{ env.VM_USER }}:${{ env.VM_USER }} ${{ env.APP_DIR }}

            # Create backup directory
            sudo mkdir -p /opt/backups
            sudo chown -R ${{ env.VM_USER }}:${{ env.VM_USER }} /opt/backups
          ENDSSH

      - name: Backup existing deployment
        continue-on-error: true
        run: |
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} << 'ENDSSH'
            if [ -d "${{ env.APP_DIR }}/.git" ]; then
              BACKUP_NAME="backup-$(date +%Y%m%d-%H%M%S)"
              echo "Creating backup: $BACKUP_NAME"
              sudo tar -czf /opt/backups/$BACKUP_NAME.tar.gz -C ${{ env.APP_DIR }} .
              echo "Backup created successfully"
            fi
          ENDSSH

      - name: Deploy code to VM
        run: |
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} << 'ENDSSH'
            cd ${{ env.APP_DIR }}

            if [ -d ".git" ]; then
              echo "Repository exists, pulling latest changes..."
              git fetch origin
              git reset --hard origin/main
              git clean -fd
            else
              echo "Cloning repository..."
              # Remove any non-git files first
              rm -rf * .* 2>/dev/null || true
              git clone https://github.com/${{ github.repository }}.git .
            fi

            echo "Current commit: $(git rev-parse --short HEAD)"
          ENDSSH

      - name: Create backend environment file
        run: |
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} "cat > ${{ env.APP_DIR }}/.env" << 'EOF'
          # Database Configuration
          DB_NAME=huntr_clone
          DB_USER=jobtracker_user
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_PORT=5432

          # Application Configuration
          NODE_ENV=production
          APP_PORT=3000
          CLIENT_URL=http://${{ env.VM_IP }}:3000
          LOG_LEVEL=info

          # Authentication Secrets
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          SESSION_SECRET=${{ secrets.SESSION_SECRET }}

          # AI Features
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}

          # Google OAuth
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_CALLBACK_URL=${{ secrets.GOOGLE_CALLBACK_URL }}
          EOF

      - name: Create frontend environment file
        run: |
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} "cat > ${{ env.APP_DIR }}/client/.env" << 'EOF'
          # Google OAuth Client ID for Frontend
          VITE_GOOGLE_CLIENT_ID=${{ secrets.VITE_GOOGLE_CLIENT_ID }}
          EOF

      - name: Deploy with Docker Compose
        run: |
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} << 'ENDSSH'
            cd ${{ env.APP_DIR }}

            echo "Stopping existing containers..."
            docker-compose down || true

            echo "Pulling latest images..."
            docker-compose pull

            echo "Building and starting services..."
            docker-compose up -d --build

            echo "Waiting for services to be healthy..."
            sleep 15
          ENDSSH

      - name: Run database migrations
        run: |
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} << 'ENDSSH'
            cd ${{ env.APP_DIR }}

            echo "Running database migrations..."
            docker-compose exec -T app npx prisma migrate deploy || echo "Migration completed or not needed"
          ENDSSH

      - name: Setup Nginx reverse proxy
        run: |
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} << 'ENDSSH'
            echo "Installing Nginx if not present..."
            if ! command -v nginx &> /dev/null; then
              sudo apt update
              sudo apt install -y nginx
            fi

            echo "Creating Nginx configuration..."
            sudo tee /etc/nginx/sites-available/jobflow > /dev/null << 'NGINX_EOF'
          server {
              listen 80;
              server_name ${{ secrets.DOMAIN_NAME || env.VM_IP }} www.${{ secrets.DOMAIN_NAME || '' }};

              # Security headers
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;

              location / {
                  proxy_pass http://localhost:3000;
                  proxy_http_version 1.1;

                  # WebSocket support
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';

                  # Headers
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;

                  # Timeouts
                  proxy_connect_timeout 60s;
                  proxy_send_timeout 60s;
                  proxy_read_timeout 60s;

                  # Cache
                  proxy_cache_bypass \$http_upgrade;
              }
          }
          NGINX_EOF

            echo "Enabling Nginx site..."
            sudo ln -sf /etc/nginx/sites-available/jobflow /etc/nginx/sites-enabled/jobflow
            sudo rm -f /etc/nginx/sites-enabled/default

            echo "Testing Nginx configuration..."
            sudo nginx -t

            echo "Restarting Nginx..."
            sudo systemctl restart nginx
            sudo systemctl enable nginx

            echo "‚úÖ Nginx configured successfully"
          ENDSSH

      - name: Setup SSL certificate (if domain configured)
        if: ${{ secrets.DOMAIN_NAME != '' }}
        continue-on-error: true
        run: |
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} << 'ENDSSH'
            echo "Installing Certbot if not present..."
            if ! command -v certbot &> /dev/null; then
              sudo apt update
              sudo apt install -y certbot python3-certbot-nginx
            fi

            echo "Attempting to get SSL certificate..."
            sudo certbot --nginx \
              -d ${{ secrets.DOMAIN_NAME }} \
              -d www.${{ secrets.DOMAIN_NAME }} \
              --non-interactive \
              --agree-tos \
              --email ${{ secrets.SSL_EMAIL || 'admin@' }}${{ secrets.DOMAIN_NAME }} \
              --redirect \
              || echo "‚ö†Ô∏è SSL setup skipped - ensure DNS is configured"

            echo "Setting up auto-renewal..."
            sudo systemctl enable certbot.timer || true

            echo "‚úÖ SSL setup attempted"
          ENDSSH

      - name: Check deployment status
        run: |
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} << 'ENDSSH'
            cd ${{ env.APP_DIR }}

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Container Status:"
            docker-compose ps

            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Health Check:"
            docker-compose exec -T app curl -f http://localhost:3000/health || echo "Health check endpoint not responding yet"

            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Recent Logs:"
            docker-compose logs --tail=30 app
          ENDSSH

      - name: Verify application is accessible
        run: |
          echo "Waiting for application to be fully ready..."
          sleep 10

          echo "Testing application endpoint..."
          curl -f http://${{ env.VM_IP }}:3000/health || curl -f http://${{ env.VM_IP }}:3000 || echo "‚ö†Ô∏è Application may still be starting up"

      - name: Deployment summary
        if: success()
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Deployment Successful!"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          if [ -n "${{ secrets.DOMAIN_NAME }}" ]; then
            echo "üåê Application URL: https://${{ secrets.DOMAIN_NAME }}"
            echo "üåê Alternative URL: http://${{ secrets.DOMAIN_NAME }}"
          else
            echo "üåê Application URL: http://${{ env.VM_IP }}"
          fi
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Deployed by: ${{ github.actor }}"
          echo "‚è∞ Time: $(date)"
          echo ""
          echo "‚úÖ Nginx reverse proxy: Configured"
          if [ -n "${{ secrets.DOMAIN_NAME }}" ]; then
            echo "‚úÖ SSL certificate: Attempted (check logs above)"
          fi
          echo ""
          echo "Useful commands:"
          echo "  ssh ${{ env.VM_USER }}@${{ env.VM_IP }}"
          echo "  cd ${{ env.APP_DIR }}"
          echo "  docker-compose ps"
          echo "  docker-compose logs -f app"
          echo "  sudo systemctl status nginx"
          echo "  sudo tail -f /var/log/nginx/error.log"
          echo ""

      - name: Rollback on failure
        if: failure()
        run: |
          echo "‚ö†Ô∏è Deployment failed, checking for backup..."
          ssh -i ~/.ssh/azure_key ${{ env.VM_USER }}@${{ env.VM_IP }} << 'ENDSSH'
            LATEST_BACKUP=$(ls -t /opt/backups/*.tar.gz 2>/dev/null | head -1)
            if [ -n "$LATEST_BACKUP" ]; then
              echo "Rolling back to: $LATEST_BACKUP"
              cd ${{ env.APP_DIR }}
              docker-compose down
              sudo tar -xzf $LATEST_BACKUP -C ${{ env.APP_DIR }}
              docker-compose up -d
              echo "Rollback completed"
            else
              echo "No backup found, manual intervention required"
            fi
          ENDSSH

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/azure_key
