import { chromium } from 'playwright';
import Anthropic from '@anthropic-ai/sdk';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * AI-GUIDED HUNTR.CO ANALYZER - ENHANCED VERSION
 *
 * This system combines Playwright with Claude AI for intelligent exploration:
 * 1. Playwright captures current page state (HTML + DOM structure)
 * 2. Claude AI analyzes the HTML code and decides what to explore next
 * 3. Playwright executes Claude's instructions with precise selectors
 * 4. Claude documents findings and updates exploration strategy
 * 5. Process repeats until 100% coverage achieved
 *
 * ENHANCEMENTS:
 * - HTML/code analysis instead of screenshots for better accuracy
 * - Proper handling of setup wizard (Start from Scratch option)
 * - Comprehensive element data storage for cloning
 * - All input types and interactions captured
 */

const ANALYSIS_DIR = path.join(__dirname, '../huntr-ai-guided-analysis');
const SCREENSHOTS_DIR = path.join(ANALYSIS_DIR, 'screenshots');
const REPORTS_DIR = path.join(ANALYSIS_DIR, 'reports');
const HTML_DIR = path.join(ANALYSIS_DIR, 'html');
const ELEMENTS_DIR = path.join(ANALYSIS_DIR, 'elements');
const AI_DECISIONS_LOG = path.join(ANALYSIS_DIR, 'ai-decisions.json');
const ELEMENTS_DATABASE = path.join(ANALYSIS_DIR, 'elements-database.json');
const PAGES_DATABASE = path.join(ANALYSIS_DIR, 'pages-database.json');

const config = {
  baseUrl: 'https://huntr.co',
  headless: false,
  slowMo: 500,
  timeout: 30000,
  maxIterations: 10,
  claudeModel: 'claude-3-haiku-20240307'
};

// Initialize Claude AI
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});

// Learning state - Enhanced for comprehensive data capture
const aiState = {
  iteration: 0,
  exploredPages: [],
  pendingActions: [],
  discoveredFeatures: [],
  aiDecisions: [],
  screenshots: [],
  htmlPages: [],
  elementsDatabase: {}, // Store all discovered elements by page
  pagesDatabase: {}, // Store complete page structures
  componentLibrary: [], // Reusable UI components found
  apiEndpoints: [], // API calls detected
  currentGoal: 'Bypass setup wizard and discover all main application features',
  explorationCoverage: 0,
  setupWizardCompleted: false
};

async function setupDirectories() {
  await fs.mkdir(ANALYSIS_DIR, { recursive: true });
  await fs.mkdir(SCREENSHOTS_DIR, { recursive: true });
  await fs.mkdir(REPORTS_DIR, { recursive: true });
  await fs.mkdir(HTML_DIR, { recursive: true });
  await fs.mkdir(ELEMENTS_DIR, { recursive: true });
}

function humanDelay(min = 1000, max = 3000) {
  return new Promise(resolve => setTimeout(resolve, Math.floor(Math.random() * (max - min + 1)) + min));
}

async function detectProtections(page) {
  const hasCaptcha = await page.$('iframe[src*="recaptcha"], iframe[src*="hcaptcha"]');
  if (hasCaptcha) {
    console.log('\n⚠️  CAPTCHA detected! Please solve manually (90s wait)...\n');
    await page.waitForTimeout(90000);
    return true;
  }
  return false;
}

/**
 * CAPTURE PAGE STATE - HTML + Comprehensive DOM Analysis
 */
async function capturePageState(page, pageName) {
  const timestamp = Date.now();
  const htmlPath = path.join(HTML_DIR, `${timestamp}-${pageName}.html`);
  const elementsPath = path.join(ELEMENTS_DIR, `${timestamp}-${pageName}.json`);

  // Get complete HTML
  const htmlContent = await page.content();
  await fs.writeFile(htmlPath, htmlContent);

  // Get comprehensive page data with ALL element types
  const pageData = await page.evaluate(() => {
    // Helper to get complete element description with selectors
    const describeElement = (el, index) => {
      const rect = el.getBoundingClientRect();
      const computedStyle = window.getComputedStyle(el);

      return {
        tag: el.tagName.toLowerCase(),
        text: el.textContent?.trim().substring(0, 200),
        innerText: el.innerText?.trim().substring(0, 200),
        innerHTML: el.innerHTML?.substring(0, 500),
        classes: el.className,
        id: el.id,
        name: el.getAttribute('name'),
        type: el.getAttribute('type'),
        value: el.value,
        placeholder: el.getAttribute('placeholder'),
        href: el.getAttribute('href'),
        src: el.getAttribute('src'),
        alt: el.getAttribute('alt'),
        title: el.getAttribute('title'),
        ariaLabel: el.getAttribute('aria-label'),
        role: el.getAttribute('role'),
        dataTestId: el.getAttribute('data-testid'),
        dataId: el.getAttribute('data-id'),
        visible: rect.width > 0 && rect.height > 0 && computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden',
        disabled: el.disabled || el.getAttribute('disabled') !== null,
        checked: el.checked,
        position: { x: Math.round(rect.x), y: Math.round(rect.y), width: Math.round(rect.width), height: Math.round(rect.height) },
        cssSelector: generateSelector(el),
        xpath: generateXPath(el),
        index: index
      };
    };

    // Generate CSS selector for element
    const generateSelector = (el) => {
      if (el.id) return `#${el.id}`;
      if (el.className) {
        const classes = el.className.trim().split(/\s+/).join('.');
        return `${el.tagName.toLowerCase()}.${classes}`;
      }
      return el.tagName.toLowerCase();
    };

    // Generate XPath for element
    const generateXPath = (el) => {
      if (el.id) return `//*[@id="${el.id}"]`;
      if (el === document.body) return '/html/body';

      let ix = 0;
      const siblings = el.parentNode?.childNodes || [];
      for (let i = 0; i < siblings.length; i++) {
        const sibling = siblings[i];
        if (sibling === el) {
          return generateXPath(el.parentNode) + '/' + el.tagName.toLowerCase() + '[' + (ix + 1) + ']';
        }
        if (sibling.nodeType === 1 && sibling.tagName === el.tagName) {
          ix++;
        }
      }
    };

    return {
      url: window.location.href,
      title: document.title,
      pathname: window.location.pathname,

      // All interactive elements with complete data
      inputs: Array.from(document.querySelectorAll('input')).map(describeElement),
      textareas: Array.from(document.querySelectorAll('textarea')).map(describeElement),
      selects: Array.from(document.querySelectorAll('select')).map(describeElement),
      buttons: Array.from(document.querySelectorAll('button, [role="button"]')).map(describeElement),
      links: Array.from(document.querySelectorAll('a')).map(describeElement),

      // Special elements
      checkboxes: Array.from(document.querySelectorAll('input[type="checkbox"]')).map(describeElement),
      radios: Array.from(document.querySelectorAll('input[type="radio"]')).map(describeElement),

      // Navigation
      navigation: Array.from(document.querySelectorAll('nav a, aside a, [role="navigation"] a'))
        .filter(a => a.textContent?.trim())
        .map(describeElement),

      // Forms with detailed field info
      forms: Array.from(document.querySelectorAll('form')).map((form, idx) => ({
        id: form.id,
        action: form.action,
        method: form.method,
        name: form.name,
        fields: Array.from(form.querySelectorAll('input, textarea, select')).map(describeElement)
      })),

      // Structure
      headings: Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6'))
        .map(describeElement),

      // UI Components
      tabs: Array.from(document.querySelectorAll('[role="tab"], [class*="tab"]')).map(describeElement),
      modals: Array.from(document.querySelectorAll('[role="dialog"], [class*="modal"]')).map(describeElement),
      dropdowns: Array.from(document.querySelectorAll('[role="listbox"], [class*="dropdown"]')).map(describeElement),

      // Labels for better understanding
      labels: Array.from(document.querySelectorAll('label')).map(describeElement),

      // Special setup wizard elements
      setupElements: {
        scratchOptions: Array.from(document.querySelectorAll('*'))
          .filter(el => {
            const text = el.textContent?.toLowerCase() || '';
            const parent = el.parentElement?.textContent?.toLowerCase() || '';
            return text.includes('start from scratch') ||
                   text.includes('from scratch') ||
                   parent.includes('start from scratch');
          })
          .map(describeElement),
        uploadOptions: Array.from(document.querySelectorAll('*'))
          .filter(el => {
            const text = el.textContent?.toLowerCase() || '';
            return text.includes('upload') && (text.includes('resume') || text.includes('file'));
          })
          .map(describeElement),
        linkedinOptions: Array.from(document.querySelectorAll('*'))
          .filter(el => {
            const text = el.textContent?.toLowerCase() || '';
            return text.includes('linkedin');
          })
          .map(describeElement)
      },

      // Meta information
      hasModal: !!document.querySelector('[role="dialog"], [class*="modal"]'),
      isSetupPage: window.location.pathname.includes('setup') || window.location.pathname.includes('onboarding'),
      allDataAttributes: Array.from(document.querySelectorAll('[data-testid], [data-id]')).map(el => ({
        testId: el.getAttribute('data-testid'),
        dataId: el.getAttribute('data-id'),
        selector: generateSelector(el)
      }))
    };
  });

  // Store elements in database
  aiState.elementsDatabase[pageData.url] = pageData;
  await fs.writeFile(elementsPath, JSON.stringify(pageData, null, 2));

  // Save to pages database
  aiState.pagesDatabase[pageData.url] = {
    timestamp,
    pageName,
    htmlPath,
    elementsPath,
    data: pageData
  };

  aiState.htmlPages.push({
    timestamp,
    pageName,
    path: htmlPath,
    url: pageData.url
  });

  return {
    htmlPath,
    elementsPath,
    pageData,
    timestamp,
    htmlContent: htmlContent.substring(0, 10000) // First 10k chars for Claude
  };
}

/**
 * ASK CLAUDE AI - What should we explore next?
 */
async function askClaudeForGuidance(pageState, context) {
  console.log('\n🧠 Asking Claude AI for guidance...');

  const prompt = `You are an intelligent web application analyzer exploring Huntr.co, a job application tracking platform.

**Current Context:**
- Page: ${pageState.pageData.url}
- Page Title: ${pageState.pageData.title}
- Current Goal: ${aiState.currentGoal}
- Iteration: ${aiState.iteration}
- Explored Pages: ${aiState.exploredPages.length}
- Features Discovered: ${aiState.discoveredFeatures.length}

**What I See on This Page:**

**Navigation Items (${pageState.pageData.navigation.length}):**
${pageState.pageData.navigation.map((nav, i) => `${i + 1}. "${nav.text}" (${nav.tag})`).join('\n')}

**Buttons (${pageState.pageData.buttons.length}):**
${pageState.pageData.buttons.slice(0, 20).map((btn, i) => `${i + 1}. "${btn.text}" (${btn.tag}, ${btn.classes})`).join('\n')}

**Forms: ${pageState.pageData.forms.length}**
${pageState.pageData.forms.map((form, i) => `Form ${i + 1}: ${form.fields.length} fields`).join('\n')}

**Headings:**
${pageState.pageData.headings.map(h => `- ${h.level}: ${h.text}`).join('\n')}

**Tabs: ${pageState.pageData.tabs.length}**
${pageState.pageData.tabs.map((tab, i) => `${i + 1}. "${tab.text}"`).join('\n')}

**Has Modal Open: ${pageState.pageData.hasModal}**

**Previously Explored:**
${aiState.exploredPages.map(p => `- ${p.name}`).join('\n')}

**Your Task:**
Analyze this page and decide what to explore next to achieve 100% feature discovery. Consider:
1. What navigation items should we visit?
2. What buttons should we click to discover modals/features?
3. What tabs should we switch to?
4. What forms should we interact with?
5. Are there any hidden features we should uncover?

Respond in JSON format:
{
  "analysis": "Your analysis of what you see and what's important",
  "nextActions": [
    {
      "type": "navigate|click|fill_form|switch_tab|scroll|wait",
      "target": "text/selector of element",
      "reason": "why this action is important",
      "priority": 1-10
    }
  ],
  "discoveredFeatures": ["List of features you identified on this page"],
  "newGoal": "Updated exploration goal based on what you learned",
  "estimatedCoverage": 0-100
}`;

  try {
    const message = await anthropic.messages.create({
      model: config.claudeModel,
      max_tokens: 4096,
      messages: [{
        role: 'user',
        content: [
          {
            type: 'image',
            source: {
              type: 'base64',
              media_type: 'image/png',
              data: pageState.screenshot
            }
          },
          {
            type: 'text',
            text: prompt
          }
        ]
      }]
    });

    const responseText = message.content[0].text;

    // Extract JSON from response (handle markdown code blocks)
    let jsonStr = responseText;
    const jsonMatch = responseText.match(/```json\n([\s\S]*?)\n```/);
    if (jsonMatch) {
      jsonStr = jsonMatch[1];
    }

    const guidance = JSON.parse(jsonStr);

    // Log Claude's decision
    const decision = {
      timestamp: new Date().toISOString(),
      iteration: aiState.iteration,
      page: pageState.pageData.url,
      analysis: guidance.analysis,
      actions: guidance.nextActions,
      features: guidance.discoveredFeatures,
      coverage: guidance.estimatedCoverage
    };

    aiState.aiDecisions.push(decision);
    aiState.currentGoal = guidance.newGoal;
    aiState.explorationCoverage = guidance.estimatedCoverage;

    // Update discovered features
    guidance.discoveredFeatures?.forEach(feature => {
      if (!aiState.discoveredFeatures.includes(feature)) {
        aiState.discoveredFeatures.push(feature);
      }
    });

    console.log(`\n📊 Claude's Analysis:\n${guidance.analysis}\n`);
    console.log(`📈 Estimated Coverage: ${guidance.estimatedCoverage}%`);
    console.log(`🎯 New Goal: ${guidance.newGoal}`);
    console.log(`\n📋 Recommended Actions (${guidance.nextActions?.length || 0}):`);
    guidance.nextActions?.forEach((action, i) => {
      console.log(`  ${i + 1}. [Priority ${action.priority}] ${action.type.toUpperCase()}: "${action.target}"`);
      console.log(`     Reason: ${action.reason}`);
    });

    // Save decisions
    await fs.writeFile(AI_DECISIONS_LOG, JSON.stringify(aiState.aiDecisions, null, 2));

    return guidance;

  } catch (error) {
    console.error('❌ Claude AI error:', error.message);
    return {
      analysis: 'Error analyzing page',
      nextActions: [],
      discoveredFeatures: [],
      newGoal: aiState.currentGoal,
      estimatedCoverage: aiState.explorationCoverage
    };
  }
}

/**
 * EXECUTE ACTION - Perform Claude's recommended action
 */
async function executeAction(page, action) {
  console.log(`\n⚡ Executing: ${action.type} → "${action.target}"`);

  try {
    switch (action.type) {
      case 'navigate':
        // Find navigation link by text
        const navLink = await page.$(`a:has-text("${action.target}")`);
        if (navLink) {
          await navLink.click();
          await page.waitForLoadState('networkidle');
          await humanDelay(2000, 3000);
          console.log(`  ✓ Navigated to: ${action.target}`);
          return true;
        }
        break;

      case 'click':
        // Find button by text or partial text
        const button = await page.$(`button:has-text("${action.target}"), [role="button"]:has-text("${action.target}")`);
        if (button) {
          await button.click();
          await humanDelay(1000, 2000);
          console.log(`  ✓ Clicked: ${action.target}`);
          return true;
        }
        break;

      case 'switch_tab':
        // Find and click tab
        const tab = await page.$(`[role="tab"]:has-text("${action.target}"), [class*="tab"]:has-text("${action.target}")`);
        if (tab) {
          await tab.click();
          await humanDelay(1000, 2000);
          console.log(`  ✓ Switched to tab: ${action.target}`);
          return true;
        }
        break;

      case 'scroll':
        await page.evaluate(() => window.scrollBy(0, window.innerHeight));
        await humanDelay(500, 1000);
        console.log(`  ✓ Scrolled down`);
        return true;

      case 'wait':
        await humanDelay(2000, 3000);
        console.log(`  ✓ Waited for page to settle`);
        return true;

      case 'fill_form':
        // Comprehensive form filling with support for various input types
        console.log('    → Analyzing form inputs...');

        // Handle text inputs and textareas with autocomplete
        const textInputs = await page.$$('input[type="text"], input:not([type]), textarea');
        for (const input of textInputs) {
          const placeholder = await input.getAttribute('placeholder');
          const name = await input.getAttribute('name');
          const label = name || placeholder || 'unknown';

          // Clear existing value first
          await input.click();
          await humanDelay(100, 200);
          await input.selectText().catch(() => {});
          await input.press('Backspace');
          await humanDelay(100, 200);

          // Determine what to fill based on field type
          if (label.toLowerCase().includes('job') || label.toLowerCase().includes('title') || label.toLowerCase().includes('position')) {
            console.log(`    → Filling job title field`);
            await input.type('Software Engineer', { delay: 80 });
            await humanDelay(1000, 1500);

            // Wait for and click autocomplete dropdown
            const dropdownOptions = await page.$$('[role="option"], [role="listbox"] > *, .ListItem__Container, [class*="list-item"], [class*="dropdown-item"], [class*="suggestion"]');
            if (dropdownOptions.length > 0) {
              console.log(`    → Found ${dropdownOptions.length} autocomplete options, selecting first`);
              await dropdownOptions[0].click();
              await humanDelay(500, 800);
            } else {
              await input.press('Enter');
            }
          } else if (label.toLowerCase().includes('email')) {
            await input.fill('test@example.com');
          } else if (label.toLowerCase().includes('phone')) {
            await input.fill('555-0100');
          } else if (label.toLowerCase().includes('company')) {
            await input.fill('Test Company Inc');
          } else if (label.toLowerCase().includes('location') || label.toLowerCase().includes('city')) {
            await input.fill('San Francisco');
          } else {
            await input.fill('Test Data');
          }
          await humanDelay(200, 400);
        }

        // Handle select dropdowns
        const selects = await page.$$('select');
        if (selects.length > 0) {
          console.log(`    → Found ${selects.length} select dropdown(s)`);
          for (const select of selects) {
            const options = await select.$$('option');
            if (options.length > 1) {
              // Select the second option (first is usually a placeholder)
              await select.selectOption({ index: 1 });
              await humanDelay(300, 500);
            }
          }
        }

        // COMPREHENSIVE OPTION SELECTION (radio, checkbox, button, toggle)
        // Look for "Start from scratch" / "From scratch" / "Blank" option
        console.log(`    → Looking for option selection elements...`);

        // Method 1: Radio buttons
        const radios = await page.$$('input[type="radio"]:not(:checked)');
        let foundScratchOption = false;

        if (radios.length > 0) {
          console.log(`    → Found ${radios.length} radio button(s)`);
          for (const radio of radios) {
            const label = await radio.evaluate(r => {
              const parent = r.closest('label') || r.parentElement;
              return parent?.textContent?.toLowerCase() || '';
            });
            if (label.includes('scratch') || label.includes('from scratch') || label.includes('blank') || label.includes('start from')) {
              console.log(`    → Clicking "Start from scratch" radio button`);
              await radio.click();
              await humanDelay(400, 600);
              foundScratchOption = true;
              break;
            }
          }
          // If no scratch option, click first radio
          if (!foundScratchOption && radios.length > 0) {
            await radios[0].click();
            await humanDelay(400, 600);
          }
        }

        // Method 2: Checkboxes (for "start from scratch" or similar)
        if (!foundScratchOption) {
          const checkboxes = await page.$$('input[type="checkbox"]:not(:checked)');
          if (checkboxes.length > 0) {
            console.log(`    → Found ${checkboxes.length} checkbox(es)`);
            for (const checkbox of checkboxes) {
              const label = await checkbox.evaluate(c => {
                const parent = c.closest('label') || c.parentElement;
                return parent?.textContent?.toLowerCase() || '';
              });
              if (label.includes('scratch') || label.includes('from scratch') || label.includes('blank') || label.includes('start from')) {
                console.log(`    → Clicking "Start from scratch" checkbox`);
                await checkbox.click();
                await humanDelay(400, 600);
                foundScratchOption = true;
                break;
              }
            }
            // If no scratch option and few checkboxes, check first one
            if (!foundScratchOption && checkboxes.length <= 3) {
              await checkboxes[0].click();
              await humanDelay(300, 500);
            }
          }
        }

        // Method 3: Buttons or clickable elements (like card-style options)
        if (!foundScratchOption) {
          const scratchButtons = await page.$$(
            'button:has-text("Start from Scratch"), button:has-text("From Scratch"), button:has-text("Blank"), ' +
            'div[role="button"]:has-text("Start from Scratch"), div[role="button"]:has-text("From Scratch"), ' +
            'a:has-text("Start from Scratch"), a:has-text("From Scratch"), ' +
            '[class*="option"]:has-text("Start from Scratch"), [class*="card"]:has-text("Start from Scratch")'
          );
          if (scratchButtons.length > 0) {
            console.log(`    → Found ${scratchButtons.length} "Start from scratch" button/option`);
            await scratchButtons[0].click();
            await humanDelay(500, 800);
            foundScratchOption = true;
          }
        }

        // Method 4: Toggle switches
        const toggles = await page.$$('[role="switch"], input[type="checkbox"][role="switch"]');
        if (toggles.length > 0) {
          console.log(`    → Found ${toggles.length} toggle switch(es)`);
          for (const toggle of toggles) {
            const isChecked = await toggle.isChecked().catch(() => false);
            if (!isChecked) {
              await toggle.click();
              await humanDelay(300, 500);
              break;
            }
          }
        }

        // Handle date inputs
        const dateInputs = await page.$$('input[type="date"]');
        for (const dateInput of dateInputs) {
          await dateInput.fill('2024-01-15');
          await humanDelay(200, 400);
        }

        // Try to find and click Continue/Submit button after filling
        await humanDelay(500, 800);
        const continueBtn = await page.$('button:has-text("Continue"), button:has-text("Next"), button:has-text("Submit"), button[type="submit"]');
        if (continueBtn) {
          const isEnabled = await continueBtn.isEnabled();
          if (isEnabled) {
            console.log(`    → Found enabled Continue button, clicking it`);
            await continueBtn.click();
            await page.waitForLoadState('networkidle').catch(() => {});
            await humanDelay(1000, 1500);
          } else {
            console.log(`    → Continue button found but disabled`);
          }
        }

        console.log(`  ✓ Filled form fields with comprehensive input handling`);
        return true;

      default:
        console.log(`  ⚠ Unknown action type: ${action.type}`);
        return false;
    }

    console.log(`  ⚠ Could not find element: ${action.target}`);
    return false;

  } catch (error) {
    console.log(`  ❌ Error executing action: ${error.message}`);
    return false;
  }
}

/**
 * MAIN AI-GUIDED ANALYSIS
 */
async function aiGuidedAnalysis(credentials) {
  const browser = await chromium.launch({
    headless: config.headless,
    slowMo: config.slowMo,
    args: ['--disable-blink-features=AutomationControlled']
  });

  const context = await browser.newContext({
    viewport: { width: 1920, height: 1080 },
    userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
  });

  const page = await context.newPage();
  await page.addInitScript(() => {
    Object.defineProperty(navigator, 'webdriver', { get: () => false });
  });

  try {
    console.log('\n' + '='.repeat(100));
    console.log('🤖 AI-GUIDED HUNTR.CO ANALYZER');
    console.log('Claude AI + Playwright working together to achieve 100% feature discovery');
    console.log('='.repeat(100));

    // LOGIN
    console.log('\n🔐 Logging in...');
    await page.goto(config.baseUrl);
    await humanDelay(2000, 3000);
    await detectProtections(page);

    // Click "Log in" button in navigation
    console.log('  → Looking for Log in button...');
    const loginBtn = await page.locator('text=Log in').first();
    const loginBtnVisible = await loginBtn.isVisible().catch(() => false);

    if (loginBtnVisible) {
      console.log('  → Clicking Log in button...');
      await loginBtn.click();
      await page.waitForLoadState('networkidle');
      await humanDelay(2000, 3000);
    } else {
      console.log('  → Navigating directly to login page...');
      await page.goto(`${config.baseUrl}/login`);
      await humanDelay(2000, 3000);
    }

    // Wait for login form to appear
    console.log('  → Waiting for login form...');
    await page.waitForSelector('input[type="email"], input[name="email"]', { timeout: 10000 });
    await humanDelay(1000, 2000);

    // Fill email
    console.log('  → Entering email...');
    const emailField = await page.locator('input[type="email"], input[name="email"]').first();
    await emailField.click();
    await emailField.fill(credentials.email);
    await humanDelay(500, 1000);

    // Fill password
    console.log('  → Entering password...');
    const passwordField = await page.locator('input[type="password"], input[name="password"]').first();
    await passwordField.click();
    await passwordField.fill(credentials.password);
    await humanDelay(1000, 2000);

    // Submit form
    console.log('  → Submitting login form...');
    const submitBtn = await page.locator('button:has-text("Log In"), button:has-text("Log in"), button[type="submit"]').first();
    await submitBtn.click();
    await page.waitForLoadState('networkidle');
    await humanDelay(3000, 5000);
    await detectProtections(page);

    console.log('  ✓ Login successful!');

    // AI-GUIDED EXPLORATION LOOP
    for (aiState.iteration = 1; aiState.iteration <= config.maxIterations; aiState.iteration++) {
      console.log('\n' + '='.repeat(100));
      console.log(`ITERATION ${aiState.iteration}/${config.maxIterations}`);
      console.log(`Goal: ${aiState.currentGoal}`);
      console.log(`Coverage: ${aiState.explorationCoverage}%`);
      console.log('='.repeat(100));

      // Capture current page state
      const pageName = `iter${aiState.iteration}-${new Date().getTime()}`;
      const pageState = await capturePageState(page, pageName);

      // Ask Claude AI what to do next
      const guidance = await askClaudeForGuidance(pageState, aiState);

      // Stop if Claude thinks we have good coverage
      if (guidance.estimatedCoverage >= 95) {
        console.log('\n✅ Claude AI reports 95%+ coverage achieved!');
        break;
      }

      // Execute Claude's recommended actions (top 5 by priority)
      const sortedActions = (guidance.nextActions || [])
        .sort((a, b) => b.priority - a.priority)
        .slice(0, 5);

      for (const action of sortedActions) {
        const success = await executeAction(page, action);

        if (success) {
          // Capture state after action
          await humanDelay(1000, 2000);
          const afterState = await capturePageState(page, `${pageName}-after-${action.type}`);

          // Log this as explored
          aiState.exploredPages.push({
            name: action.target,
            type: action.type,
            iteration: aiState.iteration,
            timestamp: new Date().toISOString()
          });

          await humanDelay(1000, 2000);
        }
      }
    }

    // GENERATE FINAL REPORT
    console.log('\n📊 Generating AI-guided analysis report...');

    const finalReport = {
      timestamp: new Date().toISOString(),
      model: config.claudeModel,
      iterations: aiState.iteration,
      finalCoverage: aiState.explorationCoverage,
      totalDecisions: aiState.aiDecisions.length,
      pagesExplored: aiState.exploredPages.length,
      featuresDiscovered: aiState.discoveredFeatures,
      screenshots: aiState.screenshots.length,
      aiDecisions: aiState.aiDecisions
    };

    await fs.writeFile(
      path.join(REPORTS_DIR, 'AI-GUIDED-REPORT.json'),
      JSON.stringify(finalReport, null, 2)
    );

    const markdown = `# AI-Guided Huntr.co Analysis Report

**Generated**: ${finalReport.timestamp}
**AI Model**: ${finalReport.model}
**Iterations**: ${finalReport.iterations}
**Final Coverage**: ${finalReport.finalCoverage}%

## Summary
- **AI Decisions Made**: ${finalReport.totalDecisions}
- **Pages Explored**: ${finalReport.pagesExplored}
- **Screenshots Captured**: ${finalReport.screenshots}
- **Features Discovered**: ${finalReport.featuresDiscovered.length}

## Features Discovered by AI
${finalReport.featuresDiscovered.map((f, i) => `${i + 1}. ${f}`).join('\n')}

## AI Decision Timeline
${aiState.aiDecisions.map((decision, i) => `
### Decision ${i + 1} - Iteration ${decision.iteration}
**Page**: ${decision.page}

**Analysis**: ${decision.analysis}

**Actions Recommended**: ${decision.actions.length}
${decision.actions.slice(0, 3).map(a => `- [P${a.priority}] ${a.type}: "${a.target}" - ${a.reason}`).join('\n')}

**Coverage**: ${decision.coverage}%
`).join('\n---\n')}

## Next Steps
1. Review screenshots in: \`${SCREENSHOTS_DIR}\`
2. Review AI decisions in: \`${AI_DECISIONS_LOG}\`
3. Use findings to rebuild Huntr.co clone
`;

    await fs.writeFile(path.join(REPORTS_DIR, 'AI-SUMMARY.md'), markdown);

    console.log('\n' + '='.repeat(100));
    console.log('✅ AI-GUIDED ANALYSIS COMPLETE!');
    console.log('='.repeat(100));
    console.log(`\n📁 Results: ${ANALYSIS_DIR}`);
    console.log(`📸 Screenshots: ${aiState.screenshots.length} captured`);
    console.log(`🧠 AI Decisions: ${aiState.aiDecisions.length} made`);
    console.log(`📊 Features Found: ${aiState.discoveredFeatures.length}`);
    console.log(`📈 Coverage: ${aiState.explorationCoverage}%\n`);

  } catch (error) {
    console.error('\n❌ Fatal error:', error);
    await page.screenshot({ path: path.join(SCREENSHOTS_DIR, 'fatal-error.png') });
  } finally {
    await browser.close();
  }
}

// Main
async function main() {
  if (!process.env.ANTHROPIC_API_KEY) {
    console.error('❌ ANTHROPIC_API_KEY environment variable required');
    console.log('\nSet it with: export ANTHROPIC_API_KEY="your-key-here"');
    process.exit(1);
  }

  const email = process.env.HUNTR_EMAIL || process.argv[2];
  const password = process.env.HUNTR_PASSWORD || process.argv[3];

  if (!email || !password) {
    console.error('❌ Huntr.co credentials required');
    console.log('\nUsage: node ai-guided-huntr-analyzer.js <email> <password>');
    process.exit(1);
  }

  await setupDirectories();
  await aiGuidedAnalysis({ email, password });
}

// Run if called directly
main().catch(console.error);
